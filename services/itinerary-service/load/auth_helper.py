"""
Authentication Helper for Load Testing

Provides utilities to handle Firebase authentication during load tests.
Supports both static tokens and dynamic token generation via Firebase Auth API.
"""

import os
import json
import time
import requests
from pathlib import Path
from typing import Optional, Dict, List
import random


class AuthHelper:
    """Helper class to manage authentication tokens for load testing."""
    
    def __init__(self, firebase_api_key: Optional[str] = None):
        """
        Initialize the auth helper.
        
        Args:
            firebase_api_key: Firebase Web API key (optional, can use env var)
        """
        self.api_key = firebase_api_key or os.getenv("FIREBASE_API_KEY", "")
        self.token_cache: Dict[str, Dict] = {}
        self.token_file = Path(__file__).parent / "tokens.json"
        self.users_file = Path(__file__).parent / "test_users.json"
        self.test_users: Optional[List[Dict]] = None
        
    def exchange_custom_token_for_id_token(self, custom_token: str) -> Optional[str]:
        """
        Exchange a Firebase custom token for an ID token.
        
        Args:
            custom_token: The custom token to exchange
            
        Returns:
            ID token string or None if exchange failed
        """
        if not self.api_key:
            print("⚠️  FIREBASE_API_KEY not set, cannot exchange tokens")
            return None
        
        url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithCustomToken?key={self.api_key}"
        
        try:
            response = requests.post(
                url,
                json={"token": custom_token, "returnSecureToken": True},
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                return data.get("idToken")
            else:
                print(f"❌ Token exchange failed: {response.status_code} - {response.text[:100]}")
                return None
        except Exception as e:
            print(f"❌ Error exchanging token: {e}")
            return None
    
    def load_tokens_from_file(self, file_path: Optional[Path] = None) -> Dict[str, Dict]:
        """
        Load tokens from JSON file.
        
        Args:
            file_path: Path to tokens file (default: tokens.json)
            
        Returns:
            Dictionary of email -> token data
        """
        if file_path is None:
            file_path = self.token_file
        
        if not file_path.exists():
            print(f"⚠️  Token file not found: {file_path}")
            return {}
        
        try:
            with open(file_path, 'r') as f:
                return json.load(f)
        except Exception as e:
            print(f"❌ Error loading tokens: {e}")
            return {}
    
    def get_id_token_for_email(self, email: str, custom_tokens: Dict[str, Dict]) -> Optional[str]:
        """
        Get an ID token for a given email.
        
        Args:
            email: User email
            custom_tokens: Dictionary of custom tokens loaded from file
            
        Returns:
            ID token string or None
        """
        # Check cache first
        if email in self.token_cache:
            cached = self.token_cache[email]
            # Check if token is still valid (tokens expire after 1 hour)
            if time.time() - cached.get('timestamp', 0) < 3000:  # 50 minutes
                return cached.get('id_token')
        
        # Get custom token and exchange it
        if email not in custom_tokens:
            return None
        
        custom_token = custom_tokens[email].get('token')
        if not custom_token:
            return None
        
        id_token = self.exchange_custom_token_for_id_token(custom_token)
        
        if id_token:
            # Cache the ID token
            self.token_cache[email] = {
                'id_token': id_token,
                'timestamp': time.time()
            }
        
        return id_token
    
    def get_static_token(self) -> Optional[str]:
        """
        Get a static bearer token from environment variable.
        Useful for quick testing with a manually obtained token.
        
        Returns:
            Bearer token string or None
        """
        return os.getenv("BEARER_TOKEN")
    
    def load_test_users(self) -> List[Dict]:
        """
        Load test user credentials from file (generated by seed_data.py).
        
        Returns:
            List of user dictionaries with email and password
        """
        if self.test_users is not None:
            return self.test_users
        
        if not self.users_file.exists():
            return []
        
        try:
            with open(self.users_file, 'r') as f:
                data = json.load(f)
                self.test_users = data.get('users', [])
                return self.test_users
        except Exception as e:
            print(f"⚠️  Failed to load test users: {e}")
            return []
    
    def get_id_token_from_password(self, email: str, password: str) -> Optional[str]:
        """
        Sign in with email/password and get an ID token.
        Uses Firebase Auth REST API.
        
        Args:
            email: User email
            password: User password
            
        Returns:
            ID token string or None
        """
        if not self.api_key:
            return None
        
        # Check cache first
        cache_key = f"{email}:{password}"
        if cache_key in self.token_cache:
            cached = self.token_cache[cache_key]
            # Check if token is still valid (tokens expire after 1 hour)
            if time.time() - cached.get('timestamp', 0) < 3000:  # 50 minutes
                return cached.get('id_token')
        
        # Sign in to get ID token
        try:
            url = f"https://identitytoolkit.googleapis.com/v1/accounts:signInWithPassword?key={self.api_key}"
            response = requests.post(
                url,
                json={
                    "email": email,
                    "password": password,
                    "returnSecureToken": True
                },
                timeout=10
            )
            
            if response.status_code == 200:
                data = response.json()
                id_token = data.get("idToken")
                
                if id_token:
                    # Cache the token
                    self.token_cache[cache_key] = {
                        'id_token': id_token,
                        'timestamp': time.time()
                    }
                    return id_token
            else:
                print(f"⚠️  Failed to sign in {email}: {response.status_code}")
                return None
        except Exception as e:
            print(f"⚠️  Error signing in {email}: {e}")
            return None
    
    def get_random_user_token(self) -> Optional[str]:
        """
        Get an ID token for a random test user.
        Useful for load testing with multiple users.
        
        Returns:
            ID token string or None
        """
        users = self.load_test_users()
        if not users:
            return None
        
        # Pick a random user
        user = random.choice(users)
        return self.get_id_token_from_password(user['email'], user['password'])


# Singleton instance
_auth_helper = None


def get_auth_helper() -> AuthHelper:
    """Get the singleton AuthHelper instance."""
    global _auth_helper
    if _auth_helper is None:
        _auth_helper = AuthHelper()
    return _auth_helper


def get_bearer_token(email: Optional[str] = None, password: Optional[str] = None) -> Optional[str]:
    """
    Get a bearer token for load testing.
    
    Priority:
    1. Static token from BEARER_TOKEN env var (simplest)
    2. Dynamic token from email/password (realistic)
    3. Random test user token (from test_users.json)
    4. None (auth disabled mode)
    
    Args:
        email: User email to get token for (optional)
        password: User password (optional)
        
    Returns:
        Bearer token string or None
    """
    helper = get_auth_helper()
    
    # Try static token first (simplest, backward compatible)
    static_token = helper.get_static_token()
    if static_token:
        return static_token
    
    # Try to sign in with email/password if provided
    if email and password and helper.api_key:
        token = helper.get_id_token_from_password(email, password)
        if token:
            return token
    
    # Try to get a random test user token (from seed_data.py output)
    if helper.api_key:
        token = helper.get_random_user_token()
        if token:
            return token
    
    # If email provided but no password, try custom tokens (legacy method)
    if email and helper.api_key:
        custom_tokens = helper.load_tokens_from_file()
        if custom_tokens:
            return helper.get_id_token_for_email(email, custom_tokens)
    
    return None

